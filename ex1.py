import re
import sys
import random
import math
import collections
from collections import defaultdict


class Ngram_Language_Model:
    """The class implements a Markov Language Model that learns a language model
        from a given text.
        It supports language generation and the evaluation of a given string.
        The class can be applied on both word level and character level.
    """

    def __init__(self, n=3, chars=False):
        """Initializing a language model object.
        Args:
            n (int): the length of the markov unit (the n of the n-gram). Defaults to 3.
            chars (bool): True iff the model consists of ngrams of characters rather then word tokens.
                          Defaults to False
        """
        self.n = n
        self.model_dict = defaultdict(int)  # a dictionary of the form {ngram:count}, holding counts of all ngrams in the specified text.
        self.chars = chars
        self.vocabulary = None   # a set of the types in the text
        self.nminus_dict = None


    def build_model(self, text):
        """populates the instance variable model_dict.

            Args:
                text (str): the text to construct the model from.
        """
        tokens = re.split(r'\s+', text)   # create a list of words out of the corpora
        tokens.remove('')

        # Every tuple of n words is joined to a string, and the Counter func creates a dict with counts
        self.model_dict = defaultdict(int, collections.Counter(" ".join(tuple(tokens[i:i+self.n])) for i in range(len(tokens)-self.n)))
        self.nminus_dict = defaultdict(int, collections.Counter(" ".join(tuple(tokens[i:i+self.n-1])) for i in range(len(tokens)-self.n+1)))
        self.vocabulary = set(tokens)
        # print(self.model_dict)   # TODO delete this line
        # print(self.nminus_dict)   # TODO delete this line

        # TODO save all the dictionaries of <n for smoothing

    def get_model_dictionary(self):
        """Returns the dictionary class object
        """
        return self.model_dict

    def get_model_window_size(self):
        """Returning the size of the context window (the n in "n-gram")
        """
        return self.n

    def P(self, candidate):
        # context = sequence.rsplit(' ', 1)[0]   # remove the last word of the sentence
        context = candidate[0]
        sequence = candidate[2]
        return self.model_dict[sequence]/self.nminus_dict[context]

    def candidates(self, context):
        """Returns a set of all possible ngrams sequences

            Args:
                context (str):

            Return:
                List.
        """
        candi = set()   # initialize the candidates set
        for w in self.vocabulary:   # add every word in vocabulary to the given context
            c = context + " " + w   # add every word in vocabulary to the given context
            if c in self.model_dict:   # verify this sequence is in the model dictionary
                candi.add((context, w, c))

        #candi1 = set(context+" "+w for w in self.vocabulary if context+" "+w in self.model_dict)
        return candi

    def generate(self, context=None, n=20):
        """Returns a string of the specified length, generated by applying the language model
        to the specified seed context. If no context is specified the context should be sampled
        from the models' contexts distribution. Generation should stop before the n'th word if the
        contexts are exhausted. If the length of the specified context exceeds (or equal to)
        the specified n, the method should return the a prefix of length n of the specified context.

            Args:
                context (str): a seed context to start the generated string from. Defaults to None
                n (int): the length of the string to be generated.

            Return:
                String. The generated text.

        """
        if context==None:
            str=None
        else:
            context_len = len(re.split(r'\s+', context))
            if  context_len < self.n-1:    # TODO change from len of context to no. of words
                # there is no given context or not big enough
                # add <s> or <s><s> or <s><s>...<s>
                str=None


            else:   # context is same length as self.n-1 or longer
                if context_len > self.n-1:   # context is loner than self.n-1
                    ngram = context.split(' ')
                    ngram = ' '.join(ngram[len(ngram) - (self.n - 1):])
                else: ngram = context   # context is exactly self.n - 1

                str = context

                for i in range(0, n-context_len):
                    chosen = self.choose(self.candidates(ngram))   # choose the word with highest probability from the list of options for next word
                    str = str + " " + chosen
                    ngram = (ngram + " " + chosen).split(' ', 1)[1]
                print(str)

        return str

    def choose(self, candidates):
        """Return the word with the highest probability to be next in the sentence based on ngrams.
        If there are more than one word with the name probability, a random choice is made.

        Args:
            candidates (list): list of possible candidates, based on ngram algorithm

        Return:
            The chosen word (str)
        """
        probs = {}   # dictionary of the candidates with their probabilities
        for c in candidates:   # c is a tuple of (ngram, predicted word, ngram+pred word)
            probs[c[1]] = self.P(c)   # calculate the probability for each candidate. c[1] is the predicted word

        return (random.choices(population=list(probs.keys()), weights=probs.values(), k=1))[0]

    def evaluate(self, text):
        """Returns the log-likelihood of the specified text to be a product of the model.
           Laplace smoothing should be applied if necessary.

           Args:
               text (str): Text to evaluate.

           Returns:
               Float. The float should reflect the (log) probability.
        """
        log_probs = []
        text_list = re.split(r'\s+', text)
        text_len = len(text_list)
        if text_len >= self.n:
            tokens = re.split(r'\s+', text)  # create a list of words out of the corpora
            # tokens.remove('')
            ngram_dict = defaultdict(int, collections.Counter(
                " ".join(tuple(tokens[i:i + self.n])) for i in range(len(tokens) - self.n)))
            ngram_minus_dict = defaultdict(int, collections.Counter(
                " ".join(tuple(tokens[i:i + self.n - 1])) for i in range(len(tokens) - self.n + 1)))

            for i in range(0,text_len-(self.n-1)):
                ngram = " ".join(text_list[i:i+self.n])
                nm_gram = " ".join(text_list[i:i+self.n-1])
                log_probs.append(math.log(self.model_dict[ngram]/self.nminus_dict[nm_gram]))

        return sum(log_probs)


    def smooth(self, ngram):
        """Returns the smoothed (Laplace) probability of the specified ngram.

            Args:
                ngram (str): the ngram to have it's probability smoothed

            Returns:
                float. The smoothed probability.
        """


def normalize_text(text):
    """Returns a normalized version of the specified string.
      You can add default parameters as you like (they should have default values!)
      You should explain your decisions in the header of the function.

      Args:
        text (str): the text to normalize

      Returns:
        string. the normalized text.
    """
    # TODO add a case when the model is for chars and not words
    nt = text.lower()   # lower-case the text
    # nt = re.sub('([.,!?()%^$&-])', r' \1 ', nt)   # add space before/after a punctuation
    # nt = re.sub(r'\s+', ' ', nt)   # remove unwanted spaces (more than 1)
    nt = re.sub('(?<! )(?=[.,:?!@#$%^&*()\[\]\\\])|(?<=[.,:?!@#$%^&*()\[\]\\\])(?! )', r' ', nt)
    return nt


def who_am_i():  # this is not a class method
    """Returns a dictionary with your name, id number and email. keys=['name', 'id','email']
        Make sure you return your own info!
    """
    return {'name': 'Eyal Ginosar', 'id': '307830901', 'email': 'eyalgi@post.bgu.ac.il'}
